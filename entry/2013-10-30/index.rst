2013-10-30 再帰型
================================================================================

.. include:: /roles.rst

型システムの勉強を進めると，ひとつ疑問に思えることがあった．それは， Y コンビネータの
型付けのことだ．型システムは，ASTを走査して，式に静的な型を付ける．ところが，
素直にYコンビネータを型付けしようとすると，おそらくなんらかの型エラーを起こす．
``(λf.(λx.f(xx))(λx.f(xx)))`` という Y コンビネータを考えよう．
``typeof(t)`` 関数は， ``typeof(λf.(λx.f(xx))(λx.f(xx)))`` の
ようにすると， ``(λf.(λx.f(xx))(λx.f(xx)))`` の型またはエラーを返すとしよう．
``typeof(λf.(λx.f(xx))(λx.f(xx)))`` の動作を追うと，

1. ``typeof(λf.(λx.f(xx))(λx.f(xx)))`` は，f の型を R と仮定し，
   ``typeof(λx.f(xx)(λx.f(xx)))`` を調べる．もしうまく型 T を つけられたら，
   型 ``R→T`` を持つ
2. ``typeof(λx.f(xx)(λx.f(xx)))`` は， ``typeof(λx.f(xx))`` (a) と
   ``typeof(λx.f(xx))`` (b) を調べる．もし a が 型 T→T' を持ち， b が
   型 T を持つなら，型 T' を持つ．
3. ``typeof(λx.f(xx))`` は， x の型を R' と仮定し，  ``typeof(f(xx))`` を
   調べる．もしうまく型 T を つけられたら，型 ``R'→T`` を持つ
4. ``typeof(f(xx))`` は，  型環境(仮定)から f をとりだす． f : R だから
   R = T→T' であるとわかる． そのあと， ``typeof(xx)`` を調べて，
   それが 型 T を持つなら型 T' を持つ．
5. ``typeof(xx)`` は，型環境(仮定)から x をとりだす
   (いま処理している x は左の x である．右ではない)．
   x : R' だから R' = T→T' であるとわかる．そのあと， ``typeof(x)`` を調べて，
   それが 型 T を持つなら型 T' を持つ．
6. ``typeof(x)`` は，，型環境(仮定)から x をとりだす．
   x : T→T' だから， T→T' を持つ．
7. \(5) に戻る． 5 では，「それが 型 T を持つなら型 T' を持つ」と言ったが，
   \(6) は T→T' である．だから，型エラーになる．

簡単に要約すると，たとえば， ``(λx.xx)`` のようなラムダに型をつけることは
できないということだ．実際， GHCi で :hs:`(\x -> x x)` のようにすると
なんかエラーがでるはずだ．

しかし，そういうラムダにも型をつけるのが再帰型というものらしい．再帰型は
型システム入門の21章で触れられている．型システム入門とかではμ型といわれて
いる．

奇しくも OCaml は再帰型をオプションで有効化できるようだ．
``-rectypes`` オプションでこれを有効化できる．
実際に試すには，次のようにすればよい．

.. code::

   $ ocaml -rectypes
   (fun x -> x x)
   # (fun x -> x x);;
   - : ('a -> 'b as 'a) -> 'b = <fun>

さて， :ml:`('a -> 'b as 'a)` という型は，型システム入門の記法を用いれば
``μX.X→Y`` のようになる． as 'a という部分が μX のように書かれる
わけだ．これは， X の部分をその型自体で置換するような型となる．
たとえば， ``μX.X→Y`` は ``(μX.X→Y)→Y`` とか ``((μX.X→Y)→Y)→Y``
になるみたいなイメージだ．

ocaml を使用して， ``μX.(X×Int)→X`` という型をあらわしてみよう．

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 1-8

:ml:`f (f, 42)` は， :ml:`(f, 42)` のような引数をとって f を返す
ということになる． f を返すということは，これにまた :ml:`(f, 42)` のように
渡してもまた f が返るということになる． :ml:`f (f, 42) (f, 42) (f, 42)` のように
してもよい．ちょうど :hs:`id id id id` みたいな感じである．

これを利用すると，再帰するタプルなどの型をあらわすことができる．

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 10-19

さて，本筋としてはこれで Yコンビネータを型付けできるかどうかだ．
実際にやってみよう．

.. literalinclude:: rectypes.ml
   :language: ocaml
   :lines: 21-45